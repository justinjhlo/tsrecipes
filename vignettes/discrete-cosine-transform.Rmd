---
title: "discrete-cosine-transform"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{discrete-cosine-transform}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE
)
```

```{r setup}
library(tsrecipes)
library(tidyverse)
```


The primary application of the discrete cosine transform is in data compression:

> data compression is the art or science of representing information in a 
  more compact form. 
  - *Sayood, K. Introduction to Data Compression*
  
There's a natural connection here to machine learning:
we often way to represent high-dimensional features with fewer dimensions, 
to save memory and computing and improve accuracy. 

Statistical techniques like Principle Component Analysis (PCA) can even
be thought of as a [data compression](http://www.statistics4u.info/fundstat_eng/cc_pca_compress.html)
algorithm.

In data compression, correlation implies redundant information. 
Coding that removes or transforms these redundancies can also be beneficial
to machine learning, where highly correlated features, such values in a time
series, may harm accuracy.

Therefore, the discrete cosine transform offers

* uncorrelated features
* unsupervised dimensionality reduction


## What is the discrete cosine transform?

Sid Shanker provides an intuitive [introduction](https://squidarth.com/rc/math/2018/06/24/fourier.html)
to the discrete cosine transform in the context of data compression. 
Let's see how we can understand by way of time series.

### Time series as wiggles

Let's think about the *wiggliness* of time series.

```{r}
ts <- ethanol$ts[[1]]
ts_dct <- tibble(
  ts = ts,
  dct = fdct(ts),
  n = 1:length(ts)
)
```

```{r}
ts_recon <- ts_dct %>%
  mutate(
    dct_lf = ifelse(seq_along(dct) <= 20, dct, 0),
    ts_lf = dtt::dct(dct_lf, inverted = TRUE),
    dct_hf = ifelse(between(seq_along(dct), 20, 40), dct, 0),
    ts_hf = dtt::dct(dct_hf, inverted = TRUE)
  )

ts_recon %>%
  pivot_longer(c(ts, ts_hf, ts_lf)) %>%
  ggplot() +
  geom_line(aes(n, value, color = name))
```

The original time series (in red) can be thought of as a combination of different
wiggles. The blue line represents the *low-frequency* wiggles: these are wiggles
that go up and down relatively slowly.

The red line represents *high-frequency* wiggles, the wiggles that change 
quickly and sharply. 

If we add those two together
```r
ts_recon = ts_hf + ts_lf
```

we can reconstruct the general shape of the original time series.

```{r}
ts_recon %>%
  mutate(ts_recon = ts_hf + ts_lf) %>%
  pivot_longer(c(ts, ts_recon)) %>%
  ggplot() +
  geom_line(aes(n, value, color = name))
```

Except there's a major difference: I decreased the dimension of the time series
from 1751 to **40**. If I would have included all the dimensions, I would have
reproduced the time series exactly.

The dimensional reduction is the magic of the discrete cosine transform. 
It allows us to remove dimensions that don't contribute to the overall "shape"
of the time series. 

### Define wiggliness

Thanks to trigonometry (SOH CAH TOA) and 
[Joseph Fourier](https://en.wikipedia.org/wiki/Joseph_Fourier),
we can very precisely define what wiggliness means.

Imagine a sequence of cosine waves, with increasing wiggles. 

```{r}
cosine <- function(i, j = 1:60) {
  cos(pi / length(j) * i * (j + 1/2))
}
```

```{r}
cosine1 <- ts_recon %>%
  rowwise() %>%
  mutate(
    cosine = list(cosine(n, j = 1:1751)),
    cosine_scale = list(dct * cosine),
    i = list(1:1751)
  ) %>%
  filter(n %in% dct_mat$i) %>%
  unnest(c(i, cosine, cosine_scale)) %>%
  ggplot() +
  geom_line(aes(i, cosine)) +
  facet_wrap(~n) +
  labs(x = NULL, y = NULL)

cosine1
```



```{r}
cosine1_scaled <- ts_recon %>%
  rowwise() %>%
  mutate(
    cosine = list(cosine(n, j = 1:1751)),
    cosine_scale = list(dct * cosine),
    i = list(1:1751)
  ) %>%
  filter(n %in% dct_mat$i) %>%
  unnest(c(i, cosine, cosine_scale)) %>%
  ggplot() +
  geom_line(aes(i, cosine_scale)) +
  facet_wrap(~n) +
  labs(x = NULL, y = NULL)
```

```{r}
library(patchwork)
cosine1 / cosine1_scaled
```

### Wiggles waver between time series



Of course, you can't necessarily assume that high frequencies are irrelevant.
It depends on the characteristics of the time series. 


```{r}
ts <- prices$ts[[1]]
ts_dct <- tibble(
  ts = ts,
  dct = fdct(ts),
  n = 1:length(ts)
)
```

```{r}
ts_recon <- ts_dct %>%
  mutate(
    dct_lf = ifelse(seq_along(dct) <= 20, dct, 0),
    ts_lf = dtt::dct(dct_lf, inverted = TRUE),
    dct_hf = ifelse(between(seq_along(dct), 40, 60), dct, 0),
    ts_hf = dtt::dct(dct_hf, inverted = TRUE)
  )

ts_recon %>%
  pivot_longer(c(ts, ts_hf, ts_lf)) %>%
  ggplot() +
  geom_line(aes(n, value, color = name))
```

This means that you either need to tune the number of frequencies keep,
or analyze the data and make a judgment.
 

